// Generated by CoffeeScript 1.7.1
var Account, Compiler, ImapReporter, ImapScheduler, Mailbox, Promise, boxAttributes, log,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Account = require('./account');

Mailbox = require('./mailbox');

ImapScheduler = require('../processes/imap_scheduler');

ImapReporter = require('../processes/imap_reporter');

Promise = require('bluebird');

log = require('../utils/logging')({
  prefix: 'models:account_imap'
});

Compiler = require('nodemailer/src/compiler');

Account.prototype.makeImapConfig = function() {
  return {
    id: this._id,
    user: this.login,
    label: this.label,
    password: this.password,
    host: this.imapServer,
    port: parseInt(this.imapPort),
    tls: (this.imapSSL == null) || this.imapSSL,
    tlsOptions: {
      rejectUnauthorized: false
    }
  };
};

Account.prototype.getScheduler = function() {
  if (this.id) {
    return ImapScheduler.instanceFor(this.id, this);
  } else {
    return Promise.resolve(new ImapScheduler(this.makeImapConfig()));
  }
};

Account.prototype.doASAP = function(gen) {
  return this.getScheduler().then(function(scheduler) {
    return scheduler.doASAP(gen);
  });
};

Account.prototype.imap_getBoxes = function() {
  return this.doASAP(function(imap) {
    return imap.getBoxes();
  });
};

Account.prototype.imap_fetchMails = function(limitByBox) {
  var reporter;
  reporter = null;
  return Mailbox.getBoxes(this.id).tap((function(_this) {
    return function(boxes) {
      log.info("FETCHING ACCOUNT ", _this.label, ":", boxes.length, "BOXES");
      return reporter = ImapReporter.accountFetch(_this, boxes.length);
    };
  })(this)).serie(function(box) {
    return box.imap_fetchMails(limitByBox)["catch"](function(err) {
      return reporter.onError(err);
    }).tap(function() {
      return reporter.addProgress(1);
    });
  })["finally"](function() {
    return reporter.onDone();
  });
};

Account.prototype.imap_createMail = function(box, message) {
  return new Promise(function(resolve, reject) {
    var mailbuilder;
    mailbuilder = new Compiler(message).compile();
    return mailbuilder.build(function(err, buffer) {
      if (err) {
        return reject(err);
      } else {
        return resolve(buffer);
      }
    });
  }).then((function(_this) {
    return function(buffer) {
      return _this.doASAP(function(imap) {
        return imap.append(buffer, {
          mailbox: box.path,
          flags: message.flags
        });
      });
    };
  })(this)).then(function(uid) {
    return [box, uid];
  });
};

Account.prototype.imap_createBox = function(path) {
  if (this.isTest()) {
    return Promise.resolve({
      path: path
    });
  }
  return this.doASAP(function(imap) {
    return imap.addBox(path);
  });
};

Account.prototype.imap_renameBox = function(oldpath, newpath) {
  if (this.isTest()) {
    return Promise.resolve({
      path: newpath
    });
  }
  return this.doASAP(function(imap) {
    return imap.renameBox(oldpath, newpath);
  });
};

Account.prototype.imap_deleteBox = function(path) {
  if (this.isTest()) {
    return Promise.resolve(null);
  }
  return this.doASAP(function(imap) {
    return imap.delBox(path);
  });
};

boxAttributes = ['inboxMailbox', 'draftMailbox', 'sentMailbox', 'trashMailbox', 'junkMailbox', 'allMailbox'];

Account.prototype.imap_scanBoxesForSpecialUse = function(boxes) {
  var box, id, inboxMailbox, priorities, type, useRFC6154, _i, _j, _len, _len1, _ref;
  useRFC6154 = false;
  inboxMailbox = null;
  boxes.map((function(_this) {
    return function(box) {
      var attribute, type, _i, _len;
      if (box.isInbox()) {
        inboxMailbox = box.id;
      } else if (type = box.RFC6154use()) {
        if (!useRFC6154) {
          useRFC6154 = true;
          for (_i = 0, _len = boxAttributes.length; _i < _len; _i++) {
            attribute = boxAttributes[_i];
            _this[attribute] = null;
          }
        }
        log.debug('found', type);
        _this[type] = box.id;
      } else if (!useRFC6154 && (type = box.guessUse())) {
        log.debug('found', type, 'guess');
        _this[type] = box.id;
      }
      return box;
    };
  })(this));
  priorities = ['inboxMailbox', 'allMailbox', 'sentMailbox', 'draftMailbox'];
  this.inboxMailbox = inboxMailbox;
  this.favorites = [];
  for (_i = 0, _len = priorities.length; _i < _len; _i++) {
    type = priorities[_i];
    if (id = this[type]) {
      this.favorites.push(id);
    }
  }
  for (_j = 0, _len1 = boxes.length; _j < _len1; _j++) {
    box = boxes[_j];
    if (this.favorites.length < 4) {
      if ((_ref = box.id, __indexOf.call(this.favorites, _ref) < 0) && __indexOf.call(box.attribs, '\\NoSelect') < 0) {
        this.favorites.push(box.id);
      }
    }
  }
  return this.savePromised();
};
