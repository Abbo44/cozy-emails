// Generated by CoffeeScript 1.7.1
var Break, FETCH_AT_ONCE, ImapReporter, ImapScheduler, Mailbox, Message, Promise, log, mailutils, _;

Mailbox = require('./mailbox');

Message = require('./message');

Promise = require('bluebird');

ImapScheduler = require('../processes/imap_scheduler');

ImapReporter = require('../processes/imap_reporter');

log = require('../utils/logging')('models:mailbox_imap');

_ = require('lodash');

mailutils = require('../utils/jwz_tools');

Break = require('../utils/errors').Break;

FETCH_AT_ONCE = require('../utils/constants').FETCH_AT_ONCE;

Mailbox.prototype.doASAPWithBox = function(gen) {
  return ImapScheduler.instanceFor(this.accountID).then((function(_this) {
    return function(scheduler) {
      return scheduler.doASAPWithBox(_this, gen);
    };
  })(this));
};

Mailbox.prototype.doLaterWithBox = function(gen) {
  return ImapScheduler.instanceFor(this.accountID).then((function(_this) {
    return function(scheduler) {
      return scheduler.doLaterWithBox(_this, gen);
    };
  })(this));
};

Mailbox.prototype.imap_fetchMails = function(limitByBox) {
  return this.imap_refreshStep(limitByBox);
};

Mailbox.prototype.imap_refreshStep = function(limitByBox, laststep) {
  var box, reporter, step;
  step = null;
  box = this;
  reporter = null;
  return this.doLaterWithBox(function(imap, imapbox) {
    if (laststep == null) {
      laststep = {
        min: imapbox.uidnext + 1
      };
    }
    if (laststep.min === 1) {
      throw new Break();
    }
    step = {
      max: Math.max(1, laststep.min - 1),
      min: Math.max(1, laststep.min - FETCH_AT_ONCE)
    };
    if (limitByBox) {
      step.min = Math.max(1, laststep.min - limitByBox);
    }
    log.info("IMAP REFRESH", box.label, "UID " + step.min + ":" + step.max);
    return Promise.all([
      imap.search([['UID', "" + step.min + ":" + step.max]]).then(function(UIDs) {
        UIDs.sort().reverse();
        return imap.fetchMetadata(UIDs);
      }), Message.UIDsInRange(box.id, step.min, step.max)
    ]);
  }).spread(function(imapUIDs, cozyIds) {
    var cozyMessage, id, imapMessage, ops, uid;
    ops = {
      toFetch: [],
      toRemove: [],
      flagsChange: []
    };
    for (uid in imapUIDs) {
      imapMessage = imapUIDs[uid];
      if (cozyMessage = cozyIds[uid]) {
        if (_.xor(imapMessage[1], cozyMessage[1]).length) {
          id = cozyMessage[0];
          ops.flagsChange.push({
            id: id,
            flags: imapMessage[1]
          });
        }
      } else {
        ops.toFetch.push({
          uid: parseInt(uid),
          mid: imapMessage[0]
        });
      }
    }
    for (uid in cozyIds) {
      cozyMessage = cozyIds[uid];
      if (!imapUIDs[uid]) {
        ops.toRemove.push(id = cozyMessage[0]);
      }
    }
    return ops;
  }).tap((function(_this) {
    return function(ops) {
      var nbTasks;
      nbTasks = ops.toFetch.length + ops.toRemove.length + ops.flagsChange.length;
      if (nbTasks > 0) {
        return reporter = ImapReporter.boxFetch(_this, nbTasks);
      }
    };
  })(this)).tap(function(ops) {
    return Promise.serie(ops.toRemove, function(id) {
      return Message.removeFromMailbox(id, box)["catch"](function(err) {
        return reporter.onError(err);
      }).tap(function() {
        return reporter.addProgress(1);
      }).delay(100);
    });
  }).tap(function(ops) {
    return Promise.serie(ops.flagsChange, function(change) {
      return Message.applyFlagsChanges(change.id, change.flags)["catch"](function(err) {
        return reporter.onError(err);
      }).tap(function() {
        return reporter.addProgress(1);
      }).delay(100);
    });
  }).tap(function(ops) {
    return Promise.serie(ops.toFetch, function(msg) {
      return Message.byMessageId(box.accountID, msg.mid).then(function(existing) {
        if (existing) {
          return existing.addToMailbox(box, msg.uid);
        } else {
          return box.imap_fetchOneMail(msg.uid);
        }
      })["catch"](function(err) {
        return reporter.onError(err);
      }).tap(function() {
        return reporter.addProgress(1);
      }).delay(100);
    });
  })["finally"](function() {
    return reporter != null ? reporter.onDone() : void 0;
  }).then((function(_this) {
    return function(ok) {
      if (!limitByBox) {
        return _this.imap_refreshStep(null, step);
      }
    };
  })(this), function(err) {
    if (err instanceof Break) {
      return 'done';
    } else {
      throw err;
    }
  });
};

Mailbox.prototype.imap_fetchOneMail = function(uid) {
  return this.doLaterWithBox(function(imap) {
    return imap.fetchOneMail(uid);
  }).then((function(_this) {
    return function(mail) {
      return Message.createFromImapMessage(mail, _this, uid);
    };
  })(this)).tap((function(_this) {
    return function() {
      return log.info("MAIL " + _this.path + "#" + uid + " CREATED");
    };
  })(this));
};

Mailbox.prototype.imap_removeMail = function(uid) {
  return this.doASAPWithBox((function(_this) {
    return function(imap) {
      return imap.openBox(_this.path).then(function() {
        return imap.addFlags(uid, '\\Deleted');
      }).then(function() {
        return imap.expunge(uid);
      }).then(function() {
        return imap.closeBox();
      });
    };
  })(this));
};

Mailbox.prototype.recoverChangedUIDValidity = function(imap) {
  var box;
  box = this;
  return imap.openBox(this.path).then(function() {
    return imap.fetchBoxMessageIds();
  }).then(function(map) {
    var reporter, uids;
    uids = _.keys(map);
    reporter = ImapReporter.recoverUIDValidty(box, uids.length);
    return Promise.serie(uids, function(newUID) {
      var messageID;
      messageID = mailutils.normalizeMessageID(map[newUID]);
      return Message.byMessageId(box.accountID, messageID).then(function(message) {
        var mailboxIDs;
        if (!message) {
          return;
        }
        mailboxIDs = message.mailboxIDs;
        mailboxIDs[box.id] = newUID;
        return message.updateAttributesPromised({
          mailboxIDs: mailboxIDs
        });
      })["catch"](function(err) {
        reporter.onError(err);
        throw err;
      }).tap(function() {
        return reporter.addProgress(1);
      });
    })["finally"](function() {
      return reporter.onDone();
    });
  });
};
