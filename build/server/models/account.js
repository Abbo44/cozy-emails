// Generated by CoffeeScript 1.7.1
var Account, AccountConfigError, ImapProcess, Mailbox, Message, Promise, SMTPConnection, americano, log, nodemailer;

americano = require('americano-cozy');

Account = (function() {
  function Account() {}

  return Account;

})();

module.exports = Account = americano.getModel('Account', {
  label: String,
  name: String,
  login: String,
  password: String,
  accountType: String,
  smtpServer: String,
  smtpPort: Number,
  smtpSSL: Boolean,
  smtpTLS: Boolean,
  imapServer: String,
  imapPort: Number,
  imapSSL: Boolean,
  imapTLS: Boolean,
  inboxMailbox: String,
  draftMailbox: String,
  sentMailbox: String,
  trashMailbox: String,
  junkMailbox: String,
  allMailbox: String,
  favorites: function(x) {
    return x;
  },
  mailboxes: function(x) {
    return x;
  }
});

nodemailer = require('nodemailer');

Mailbox = require('./mailbox');

ImapProcess = require('../processes/imap_processes');

Promise = require('bluebird');

Message = require('./message');

AccountConfigError = require('../utils/errors').AccountConfigError;

log = require('../utils/logging')({
  prefix: 'models:account'
});

SMTPConnection = require('nodemailer/node_modules/' + 'nodemailer-smtp-transport/node_modules/smtp-connection');

Account.refreshAllAccounts = function() {
  var allAccounts;
  allAccounts = Account.requestPromised('all');
  return Promise.serie(allAccounts, function(account) {
    if (!account.accountType === 'TEST') {
      return ImapProcess.fetchAccount(account);
    }
  });
};

Account.prototype.fetchMails = function() {
  return ImapProcess.fetchAccount(this);
};

Account.prototype.includeMailboxes = function() {
  return Mailbox.getClientTree(this.id).then((function(_this) {
    return function(mailboxes) {
      return _this.mailboxes = mailboxes;
    };
  })(this))["return"](this);
};

Account.createIfValid = function(data) {
  var pAccount, pAccountReady, pBoxes, pSpecialUseBoxes;
  pBoxes = data.accountType === 'TEST' ? Promise.resolve([]) : Account.testSMTPConnection(data).then(function() {
    return ImapProcess.fetchBoxesTree(data);
  });
  pAccount = pBoxes.then(function() {
    return Account.createPromised(data);
  });
  pSpecialUseBoxes = Promise.join(pAccount, pBoxes, function(account, boxes) {
    return Mailbox.createBoxesFromImapTree(account.id, boxes);
  });
  pAccountReady = Promise.join(pAccount, pSpecialUseBoxes, function(account, specialUses) {
    return account.updateAttributesPromised(specialUses);
  });
  pAccountReady.then(function(account) {
    return ImapProcess.fetchAccount(account, 100).then(function() {
      return ImapProcess.fetchAccount(account);
    })["catch"](function(err) {
      return log.error("FETCH MAIL FAILED", err);
    });
  });
  return pAccountReady.then(function(account) {
    return account.includeMailboxes();
  });
};

Account.prototype.sendMessage = function(message, callback) {
  var transport;
  transport = nodemailer.createTransport({
    port: this.smtpPort,
    host: this.smtpServer,
    tls: {
      rejectUnauthorized: false
    },
    auth: {
      user: this.login,
      pass: this.password
    }
  });
  return transport.sendMail(message, callback);
};

Account.testSMTPConnection = function(data) {
  var auth, connection;
  connection = new SMTPConnection({
    port: data.smtpPort,
    host: data.smtpServer,
    tls: {
      rejectUnauthorized: false
    }
  });
  auth = {
    user: data.login,
    pass: data.password
  };
  return new Promise(function(resolve, reject) {
    var timeout;
    connection.once('error', function(err) {
      log.warn("SMTP CONNECTION ERROR", err);
      return reject(new AccountConfigError('smtpServer'));
    });
    timeout = setTimeout(function() {
      reject(new AccountConfigError('smtpPort'));
      return connection.close();
    }, 10000);
    return connection.connect(function(err) {
      if (err) {
        return reject(new AccountConfigError('smtpServer'));
      }
      clearTimeout(timeout);
      return connection.login(auth, function(err) {
        if (err) {
          reject(new AccountConfigError('auth'));
        } else {
          resolve('ok');
        }
        return connection.close();
      });
    });
  });
};

Account.prototype.destroyEverything = function() {
  var accountDestroyed, accountID;
  accountDestroyed = this.destroyPromised();
  accountID = this.id;
  accountDestroyed.then(function() {
    return Mailbox.rawRequestPromised('treemap', {
      startkey: [accountID],
      endkey: [accountID, {}]
    });
  }).map(function(row) {
    return new Mailbox({
      id: row.id
    }).destroy()["catch"](function(err) {
      return log.warn("FAIL TO DELETE BOX", row.id);
    });
  }).then(function() {
    return Message.safeDestroyByAccountID(accountID);
  });
  return accountDestroyed;
};

Promise.promisifyAll(Account, {
  suffix: 'Promised'
});

Promise.promisifyAll(Account.prototype, {
  suffix: 'Promised'
});
