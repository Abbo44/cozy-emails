// Generated by CoffeeScript 1.7.1
var CONCURRENT_DESTROY, CONSTANTS, LIMIT_DESTROY, LIMIT_UPDATE, MSGBYPAGE, Mailbox, Message, Promise, americano, log, mailutils, uuid, _;

americano = require('americano-cozy');

module.exports = Message = americano.getModel('Message', {
  accountID: String,
  messageID: String,
  normSubject: String,
  conversationID: String,
  mailboxIDs: function(x) {
    return x;
  },
  flags: function(x) {
    return x;
  },
  headers: function(x) {
    return x;
  },
  from: function(x) {
    return x;
  },
  to: function(x) {
    return x;
  },
  cc: function(x) {
    return x;
  },
  bcc: function(x) {
    return x;
  },
  replyTo: function(x) {
    return x;
  },
  subject: String,
  inReplyTo: function(x) {
    return x;
  },
  references: function(x) {
    return x;
  },
  text: String,
  html: String,
  date: Date,
  priority: String,
  binary: function(x) {
    return x;
  },
  attachments: function(x) {
    return x;
  }
});

mailutils = require('../utils/jwz_tools');

CONSTANTS = require('../utils/constants');

MSGBYPAGE = CONSTANTS.MSGBYPAGE, LIMIT_DESTROY = CONSTANTS.LIMIT_DESTROY, LIMIT_UPDATE = CONSTANTS.LIMIT_UPDATE, CONCURRENT_DESTROY = CONSTANTS.CONCURRENT_DESTROY;

uuid = require('uuid');

_ = require('lodash');

log = require('../utils/logging')({
  prefix: 'models:message'
});

Promise = require('bluebird');

Mailbox = require('./mailbox');

Message.getResultsAndCount = function(mailboxID, params) {
  var after, before, descending, flag, options, pCount, pResults, sortField, _ref;
  before = params.before, after = params.after, descending = params.descending, sortField = params.sortField, flag = params.flag;
  if (flag == null) {
    flag = null;
  }
  if (descending) {
    _ref = [after, before], before = _ref[0], after = _ref[1];
  }
  options = {
    descending: descending,
    startkey: [sortField, mailboxID, flag, before],
    endkey: [sortField, mailboxID, flag, after],
    reduce: true,
    group_level: 2
  };
  pCount = Message.rawRequestPromised('byMailboxRequest', options);
  delete options.group_level;
  options.reduce = false;
  options.include_docs = true;
  options.limit = MSGBYPAGE;
  if (params.resultsAfter) {
    options.startkey[3] = params.resultsAfter;
    options.skip = 1;
  }
  pResults = Message.rawRequestPromised('byMailboxRequest', options).map(function(row) {
    return new Message(row.doc);
  });
  return Promise.join(pResults, pCount, function(messages, count) {
    var _ref1;
    return {
      messages: messages,
      count: ((_ref1 = count[0]) != null ? _ref1.value : void 0) || 0
    };
  });
};

Message.UIDsInRange = function(mailboxID, min, max) {
  var result;
  result = {};
  return Message.rawRequestPromised('byMailboxRequest', {
    startkey: ['uid', mailboxID, min],
    endkey: ['uid', mailboxID, max],
    inclusive_end: true,
    reduce: false
  }).map(function(row) {
    var uid;
    uid = row.key[2];
    return result[uid] = [row.id, row.value];
  }).then(function() {
    return result;
  });
};

Message.byMessageId = function(accountID, messageID) {
  messageID = mailutils.normalizeMessageID(messageID);
  return Message.rawRequestPromised('dedupRequest', {
    key: [accountID, 'mid', messageID],
    include_docs: true
  }).then(function(rows) {
    var data, _ref;
    if (data = (_ref = rows[0]) != null ? _ref.doc : void 0) {
      return new Message(data);
    }
  });
};

Message.byConversationId = function(conversationID) {
  return Message.rawRequestPromised('byConversationId', {
    key: conversationID,
    include_docs: true
  }).map(function(row) {
    return new Message(row.doc);
  });
};

Message.destroyByID = function(messageID, cb) {
  return Message.adapter.destroy(null, messageID, cb);
};

Message.safeDestroyByAccountID = function(accountID, retries) {
  var destroyOne;
  if (retries == null) {
    retries = 2;
  }
  destroyOne = function(row) {
    return Message.destroyByIDPromised(row.id).delay(100);
  };
  return Message.rawRequestPromised('dedupRequest', {
    limit: LIMIT_DESTROY,
    startkey: [accountID],
    endkey: [accountID, {}]
  }).map(destroyOne, {
    concurrency: CONCURRENT_DESTROY
  }).then(function(results) {
    if (results.length === 0) {
      return 'done';
    }
    return Message.safeDestroyByAccountID(accountID, 2);
  }, function(err) {
    if (!(retries > 0)) {
      throw err;
    }
    return Promise.delay(4000).then(function() {
      return Message.safeDestroyByAccountID(accountID, retries - 1);
    });
  });
};

Message.safeRemoveAllFromBox = function(mailboxID, retries) {
  var removeOne;
  if (retries == null) {
    retries = 2;
  }
  removeOne = function(row) {
    return new Message(row.doc).removeFromMailbox({
      id: mailboxID
    });
  };
  log.info("REMOVING ALL MESSAGES FROM " + mailboxID);
  return Message.rawRequestPromised('byMailboxRequest', {
    limit: LIMIT_UPDATE,
    startkey: ['uid', mailboxID, 0],
    endkey: ['uid', mailboxID, {}],
    include_docs: true,
    reduce: false
  }).tap(function(results) {
    return log.info("  LOAD " + results.length + " MESSAGES");
  }).map(removeOne, {
    concurrency: CONCURRENT_DESTROY
  }).then(function(results) {
    if (results.length < LIMIT_UPDATE) {
      return 'done';
    }
    return Message.safeRemoveAllFromBox(mailboxID, 2);
  }, function(err) {
    log.warn("ERROR ON MESSAGE REMOVAL", err.stack);
    if (!(retries > 0)) {
      throw err;
    }
    return Promise.delay(4000).then(function() {
      return Message.safeRemoveAllFromBox(mailboxID, retries - 1);
    });
  });
};

Message.prototype.addToMailbox = function(box, uid) {
  log.info("MAIL " + box.path + ":" + uid + " ADDED TO BOX");
  this.mailboxIDs[box.id] = uid;
  return this.savePromised();
};

Message.prototype.removeFromMailbox = function(box, noDestroy) {
  var isOrphan, mailboxIDs;
  if (noDestroy == null) {
    noDestroy = false;
  }
  mailboxIDs = this.mailboxIDs;
  delete mailboxIDs[box.id];
  isOrphan = Object.keys(mailboxIDs).length === 0;
  log.info("REMOVING " + this.id + ", NOW ORPHAN = ", isOrphan);
  if (isOrphan && !noDestroy) {
    return this.destroyPromised();
  } else {
    return this.updateAttributesPromised({
      mailboxIDs: mailboxIDs
    });
  }
};

Message.removeFromMailbox = function(id, box) {
  return Message.findPromised(id).then(function(message) {
    return message.removeFromMailbox(box);
  });
};

Message.applyFlagsChanges = function(id, flags) {
  return Message.findPromised(id).then(function(message) {
    return message.updateAttributesPromised({
      flags: flags
    });
  });
};

Message.prototype.applyPatchOperations = function(patch) {
  var boxOps, boxid, flagOps, index, operation, _i, _j, _len, _len1;
  boxOps = {
    addTo: [],
    removeFrom: []
  };
  for (_i = 0, _len = patch.length; _i < _len; _i++) {
    operation = patch[_i];
    if (!(operation.path.indexOf('/mailboxIDs/') === 0)) {
      continue;
    }
    boxid = operation.path.substring(12);
    if (operation.op === 'add') {
      boxOps.addTo.push(boxid);
    } else if (operation.op === 'remove') {
      boxOps.removeFrom.push(boxid);
    } else {
      throw new Error('modifying UID is not possible');
    }
  }
  flagOps = {
    add: [],
    remove: []
  };
  for (_j = 0, _len1 = patch.length; _j < _len1; _j++) {
    operation = patch[_j];
    if (!(operation.path.indexOf('/flags/') === 0)) {
      continue;
    }
    index = parseInt(operation.path.substring(7));
    if (operation.op === 'add') {
      flagOps.add.push(operation.value);
    } else if (operation.op === 'remove') {
      flagOps.remove.push(this.flags[index]);
    } else if (operation.op === 'replace') {
      flagOps.remove.push(this.flags[index]);
      flagOps.add.push(operation.value);
    }
  }
  return this.imap_applyChanges(flagOps, boxOps).then((function(_this) {
    return function() {
      return _this.savePromised();
    };
  })(this));
};

Message.createFromImapMessage = function(mail, box, uid) {
  var attachments, messageID;
  mail.accountID = box.accountID;
  mail.mailboxIDs = {};
  mail.mailboxIDs[box._id] = uid;
  messageID = mail.headers['message-id'];
  if (messageID) {
    mail.messageID = mailutils.normalizeMessageID(messageID);
  }
  if (mail.subject) {
    mail.normSubject = mailutils.normalizeSubject(mail.subject);
  }
  mail.replyTo = [];
  if (mail.cc == null) {
    mail.cc = [];
  }
  if (mail.bcc == null) {
    mail.bcc = [];
  }
  if (mail.to == null) {
    mail.to = [];
  }
  if (mail.from == null) {
    mail.from = [];
  }
  attachments = [];
  if (mail.attachments) {
    attachments = mail.attachments.map(function(att) {
      var buffer, out;
      buffer = att.content;
      delete att.content;
      return out = {
        name: att.generatedFileName,
        buffer: buffer
      };
    });
  }
  return Promise.resolve(mail['x-gm-thrid'] || Message.findConversationIdByMessageIds(mail) || Message.findConversationIdBySubject(mail)).then(function(conversationID) {
    mail.conversationID = conversationID;
    return Message.createPromised(mail);
  }).then(function(jdbMessage) {
    return Promise.serie(attachments, function(att) {
      if (att.buffer == null) {
        att.buffer = new Buffer(0);
      }
      att.buffer.path = encodeURI(att.name);
      return jdbMessage.attachBinaryPromised(att.buffer, {
        name: att.name
      });
    });
  });
};

Message.findConversationIdByMessageIds = function(mail) {
  var references;
  references = mail.references || [];
  references.concat(mail.inReplyTo || []);
  references = references.map(mailutils.normalizeMessageID).filter(function(mid) {
    return mid;
  });
  if (!references.length) {
    return null;
  }
  return Message.rawRequestPromised('dedupRequest', {
    keys: references.map(function(id) {
      return [mail.accountID, 'mid', id];
    })
  }).then(Message.pickConversationID);
};

Message.findConversationIdBySubject = function(mail) {
  var _ref;
  if (!(((_ref = mail.normSubject) != null ? _ref.length : void 0) > 3)) {
    return null;
  }
  return Message.rawRequestPromised('dedupRequest', {
    key: [mail.accountID, 'subject', mail.normSubject]
  }).then(Message.pickConversationID);
};

Message.pickConversationID = function(rows) {
  var change, conversationID, conversationIDCounts, count, pickedConversationID, pickedConversationIDCount, row, _i, _len, _name;
  conversationIDCounts = {};
  for (_i = 0, _len = rows.length; _i < _len; _i++) {
    row = rows[_i];
    if (conversationIDCounts[_name = row.value] == null) {
      conversationIDCounts[_name] = 1;
    }
    conversationIDCounts[row.value]++;
  }
  pickedConversationID = null;
  pickedConversationIDCount = 0;
  for (conversationID in conversationIDCounts) {
    count = conversationIDCounts[conversationID];
    if (count > pickedConversationIDCount) {
      pickedConversationID = conversationID;
      pickedConversationIDCount = count;
    }
  }
  if (!((pickedConversationID != null) && pickedConversationID !== 'undefined')) {
    pickedConversationID = uuid.v4();
  }
  change = {
    conversationID: pickedConversationID
  };
  return Promise.serie(rows, function(row) {
    return Message.findPromised(row.id).then(function(message) {
      if (message.conversationID !== pickedConversationID) {
        return message.updateAttributesPromised(change);
      }
    });
  })["return"](pickedConversationID);
};

require('./message_imap');

Promise.promisifyAll(Message, {
  suffix: 'Promised'
});

Promise.promisifyAll(Message.prototype, {
  suffix: 'Promised'
});
