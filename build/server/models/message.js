// Generated by CoffeeScript 1.7.1
var CONCURRENT_DESTROY, Compiler, ImapProcess, LIMIT_DESTROY, Mailbox, Message, Promise, americano, mailutils, uuid;

americano = require('americano-cozy');

module.exports = Message = americano.getModel('Message', {
  accountID: String,
  messageID: String,
  normSubject: String,
  conversationID: String,
  mailboxIDs: function(x) {
    return x;
  },
  flags: function(x) {
    return x;
  },
  headers: function(x) {
    return x;
  },
  from: function(x) {
    return x;
  },
  to: function(x) {
    return x;
  },
  cc: function(x) {
    return x;
  },
  bcc: function(x) {
    return x;
  },
  replyTo: function(x) {
    return x;
  },
  subject: String,
  inReplyTo: function(x) {
    return x;
  },
  references: function(x) {
    return x;
  },
  text: String,
  html: String,
  date: Date,
  priority: String,
  binary: function(x) {
    return x;
  },
  attachments: function(x) {
    return x;
  },
  flags: function(x) {
    return x;
  }
});

mailutils = require('../utils/jwz_tools');

uuid = require('uuid');

ImapProcess = require('../processes/imap_processes');

Promise = require('bluebird');

Mailbox = require('./mailbox');

Compiler = require('nodemailer/src/compiler');

Message.getByMailboxAndDate = function(mailboxID, params) {
  var options;
  options = {
    startkey: [mailboxID, {}],
    endkey: [mailboxID],
    include_docs: true,
    descending: true,
    reduce: false
  };
  if (params) {
    if (params.numByPage) {
      options.limit = params.numByPage;
    }
    if (params.numPage) {
      options.skip = params.numByPage * params.numPage;
    }
  }
  return Message.rawRequestPromised('byMailboxAndDate', options).map(function(row) {
    return new Message(row.doc);
  });
};

Message.countByMailbox = function(mailboxID) {
  return Message.rawRequestPromised('byMailboxAndDate', {
    startkey: [mailboxID],
    endkey: [mailboxID, {}],
    reduce: true,
    group_level: 1
  }).then(function(result) {
    var _ref;
    return ((_ref = result[0]) != null ? _ref.value : void 0) || 0;
  });
};

Message.countReadByMailbox = function(mailboxID) {
  return Message.rawRequestPromised('byMailboxAndFlag', {
    key: [mailboxID, '\\Seen'],
    reduce: true,
    group_level: 1
  }).then(function(result) {
    var _ref;
    return ((_ref = result[0]) != null ? _ref.value : void 0) || 0;
  });
};

Message.getUIDs = function(mailboxID) {
  return Message.rawRequestPromised('byMailboxAndDate', {
    startkey: [mailboxID],
    endkey: [mailboxID, {}],
    reduce: false
  }).map(function(row) {
    return [row.id, row.value];
  });
};

Message.byMessageId = function(accountID, messageID) {
  messageID = mailutils.normalizeMessageID(messageID);
  return Message.rawRequestPromised('byMessageId', {
    key: [accountID, messageID],
    include_docs: true
  }).then(function(rows) {
    var data, _ref;
    if (data = (_ref = rows[0]) != null ? _ref.doc : void 0) {
      return new Message(data);
    }
  });
};

Message.byConversationId = function(conversationID) {
  return Message.rawRequestPromised('byConversationId', {
    key: conversationID,
    include_docs: true
  }).map(function(row) {
    return new Message(row.doc);
  });
};

Message.destroyByID = function(messageID, cb) {
  return Message.adapter.destroy(null, messageID, cb);
};

LIMIT_DESTROY = 200;

CONCURRENT_DESTROY = 5;

Message.safeDestroyByAccountID = function(accountID, retries) {
  var destroyOne;
  if (retries == null) {
    retries = 2;
  }
  destroyOne = function(row) {
    return Message.destroyByIDPromised(row.id);
  };
  return Message.rawRequestPromised('treemap', {
    limit: LIMIT_DESTROY,
    startkey: [accountID],
    endkey: [accountID, {}]
  }).map(destroyOne, {
    concurrency: CONCURRENT_DESTROY
  }).then(function(results) {
    if (results.length === 0) {
      return 'done';
    }
    return Message.safeDestroyByAccountID(accountID, 2);
  }, function(err) {
    if (!(retries > 0)) {
      throw err;
    }
    return Promise.delay(4000).then(function() {
      return Message.safeDestroyByAccountID(accountID, retries - 1);
    });
  });
};

Message.safeRemoveAllFromBox = function(mailboxID, retries) {
  var removeOne;
  if (retries == null) {
    retries = 2;
  }
  removeOne = function(message) {
    return message.removeFromMailbox({
      id: mailboxID
    });
  };
  return Message.getByMailboxAndDate(mailboxID, {
    numByPage: 30,
    numPage: 0
  }).map(removeOne, {
    concurrency: CONCURRENT_DESTROY
  }).then(function(results) {
    if (results.length === 0) {
      return 'done';
    }
    return Message.safeRemoveAllFromBox(mailboxID, 2);
  }, function(err) {
    if (!(retries > 0)) {
      throw err;
    }
    return Promise.delay(4000).then(function() {
      return Message.safeRemoveAllFromBox(mailboxID, retries - 1);
    });
  });
};

Message.prototype.addToMailbox = function(box, uid) {
  this.mailboxIDs[box.id] = uid;
  return this.savePromised();
};

Message.prototype.removeFromMailbox = function(box, noDestroy) {
  if (noDestroy == null) {
    noDestroy = false;
  }
  delete this.mailboxIDs[box.id];
  if (noDestroy || Object.keys(this.mailboxIDs).length > 0) {
    return this.savePromised();
  } else {
    return this.destroyPromised();
  }
};

Message.prototype.applyPatchOperations = function(patch) {
  var boxOps, boxid, flagOps, index, operation, _i, _j, _len, _len1;
  boxOps = {
    addTo: [],
    removeFrom: []
  };
  for (_i = 0, _len = patch.length; _i < _len; _i++) {
    operation = patch[_i];
    if (!(operation.path.indexOf('/mailboxIDs/') === 0)) {
      continue;
    }
    boxid = operation.path.substring(12);
    if (operation.op === 'add') {
      boxOps.addTo.push(boxid);
    } else if (operation.op === 'remove') {
      boxOps.removeFrom.push(boxid);
    } else {
      throw new Error('modifying UID is not possible');
    }
  }
  flagOps = {
    add: [],
    remove: []
  };
  for (_j = 0, _len1 = patch.length; _j < _len1; _j++) {
    operation = patch[_j];
    if (!(operation.path.indexOf('/flags/') === 0)) {
      continue;
    }
    index = parseInt(operation.path.substring(7));
    if (operation.op === 'add') {
      flagOps.add.push(operation.value);
    } else if (operation.op === 'remove') {
      flagOps.remove.push(this.flags[index]);
    } else if (operation.op === 'replace') {
      flagOps.remove.push(this.flags[index]);
      flagOps.add.push(operation.value);
    }
  }
  return ImapProcess.applyMessageChanges(this, flagOps, boxOps).then((function(_this) {
    return function() {
      return _this.savePromised();
    };
  })(this));
};

Message.prototype.moveToTrash = function() {
  return Account.findPromised(this.accountID).then((function(_this) {
    return function(account) {
      var patch, trashID;
      trashID = account.trashMailbox;
      if (!trashID) {
        throw new WrongConfigError('need define trash');
      }
      patch = Object.keys(_this.mailboxIDs).filter(function(boxid) {
        return boxid !== trashID;
      }).map(function(boxid) {
        return {
          op: 'remove',
          path: "/mailboxIDs/" + boxid
        };
      });
      patch.push({
        op: 'add',
        path: "/mailboxIDs/" + trashID
      });
      return _this.applyPatchOperations(patch);
    };
  })(this));
};

Message.toRawMessage = function(message, callback) {
  var mailbuilder;
  mailbuilder = new Compiler(message).compile();
  return mailbuilder.build(callback);
};

Message.saveOnImapServer = function(message, boxtype, uid) {
  return Account.findPromised(message.accountID).then((function(_this) {
    return function(account) {
      var boxID;
      boxID = account[boxtype];
      if (!boxid) {
        throw new WrongConfigError('wrong boxtype');
      }
      return Mailbox.findPromised(boxID).then(function(box) {
        return ImapProcess.createMail(account, box, message);
      }).then(function(uid) {
        message.mailboxIDs[box.id] = uid;
        return Message.createPromised(message);
      });
    };
  })(this));
};

Message.createFromImapMessage = function(mail, box, uid) {
  var attachments, messageID;
  mail.accountID = box.accountID;
  mail.mailboxIDs = {};
  mail.mailboxIDs[box._id] = uid;
  messageID = mail.headers['message-id'];
  if (messageID) {
    mail.messageID = mailutils.normalizeMessageID(messageID);
  }
  if (mail.subject) {
    mail.normSubject = mailutils.normalizeSubject(mail.subject);
  }
  mail.replyTo = [];
  if (mail.cc == null) {
    mail.cc = [];
  }
  if (mail.bcc == null) {
    mail.bcc = [];
  }
  if (mail.to == null) {
    mail.to = [];
  }
  if (mail.from == null) {
    mail.from = [];
  }
  attachments = [];
  if (mail.attachments) {
    attachments = mail.attachments.map(function(att) {
      var buffer, out;
      buffer = att.content;
      delete att.content;
      return out = {
        name: att.generatedFileName,
        buffer: buffer
      };
    });
  }
  return Promise.resolve(mail['x-gm-thrid'] || Message.findConversationIdByMessageIds(mail) || Message.findConversationIdBySubject(mail)).then(function(conversationID) {
    mail.conversationID = conversationID;
    return Message.createPromised(mail);
  }).then(function(jdbMessage) {
    return Promise.serie(attachments, function(att) {
      if (att.buffer == null) {
        att.buffer = new Buffer(0);
      }
      att.buffer.path = encodeURI(att.name);
      return jdbMessage.attachBinaryPromised(att.buffer, {
        name: encodeURI(att.name)
      });
    });
  });
};

Message.findConversationIdByMessageIds = function(mail) {
  var references;
  references = mail.references || [];
  references.concat(mail.inReplyTo || []);
  references = references.map(mailutils.normalizeMessageID).filter(function(mid) {
    return mid;
  });
  if (!references.length) {
    return null;
  }
  return Message.rawRequestPromised('byMessageId', {
    keys: messageIds.map(function(id) {
      return [mail.accountID, id];
    })
  }).then(Message.pickConversationID);
};

Message.findConversationIdBySubject = function(mail) {
  var _ref;
  if (!(((_ref = mail.normSubject) != null ? _ref.length : void 0) > 3)) {
    return null;
  }
  return Message.rawRequestPromised('byNormSubject', {
    key: [mail.accountID, mail.normSubject]
  }).then(Message.pickConversationID);
};

Message.pickConversationID = function(rows) {
  var change, conversationID, conversationIDCounts, count, pickedConversationID, pickedConversationIDCount, row, _i, _len, _name;
  conversationIDCounts = {};
  for (_i = 0, _len = rows.length; _i < _len; _i++) {
    row = rows[_i];
    if (conversationIDCounts[_name = row.value] == null) {
      conversationIDCounts[_name] = 1;
    }
    conversationIDCounts[row.value]++;
  }
  pickedConversationID = null;
  pickedConversationIDCount = 0;
  for (conversationID in conversationIDCounts) {
    count = conversationIDCounts[conversationID];
    if (count > pickedConversationIDCount) {
      pickedConversationID = conversationID;
      pickedConversationIDCount = count;
    }
  }
  if (!((pickedConversationID != null) && pickedConversationID !== 'undefined')) {
    pickedConversationID = uuid.v4();
  }
  change = {
    conversationID: pickedConversationID
  };
  return Promise.serie(rows, function(row) {
    return Message.findPromised(row.id).then(function(message) {
      if (message.conversationID !== pickedConversationID) {
        return message.updateAttributesPromised(change);
      }
    });
  })["return"](pickedConversationID);
};

Promise.promisifyAll(Message, {
  suffix: 'Promised'
});

Promise.promisifyAll(Message.prototype, {
  suffix: 'Promised'
});
