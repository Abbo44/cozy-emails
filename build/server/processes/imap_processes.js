// Generated by CoffeeScript 1.7.1
var Account, ImapProcess, ImapReporter, ImapScheduler, Mailbox, Message, Promise, log, _,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = ImapProcess = (function() {
  function ImapProcess() {}

  return ImapProcess;

})();

ImapScheduler = require('./imap_scheduler');

ImapReporter = require('./imap_reporter');

Promise = require('bluebird');

Message = require('../models/message');

Mailbox = require('../models/mailbox');

Account = require('../models/account');

_ = require('lodash');

log = require('../utils/logging')({
  prefix: 'imap:processes'
});

ImapProcess.fetchBoxesTree = function(account) {
  return ImapScheduler.instanceFor(account).doASAP(function(imap) {
    log.info("FETCH BOX TREE");
    return imap.getBoxes();
  });
};

ImapProcess.fetchAccount = function(account, limitByBox) {
  if (limitByBox == null) {
    limitByBox = false;
  }
  return Mailbox.getBoxes(account.id).then(function(boxes) {
    return Promise.serie(boxes, function(box) {
      return ImapProcess.fetchMailbox(account, box, limitByBox)["catch"](function(err) {
        return log.error("FAILED TO FETCH BOX", box.path, err.stack);
      });
    });
  });
};

ImapProcess.fetchMailbox = function(account, box, limitByBox) {
  var reporter;
  if (limitByBox == null) {
    limitByBox = false;
  }
  reporter = ImapReporter.addUserTask({
    code: 'diff',
    total: 1,
    account: account.label,
    box: box.path
  });
  return ImapScheduler.instanceFor(account).doLaterWithBox(box, function(imap) {
    reporter.addProgress(0.1);
    return Promise.all([
      imap.search([['ALL']]).tap(function() {
        return reporter.addProgress(0.5);
      }), Message.getUIDs(box.id).tap(function() {
        return reporter.addProgress(0.3);
      })
    ]);
  }).spread(function(imapIds, cozyIds) {
    var ids, toDo, toFetch, toRemove;
    toFetch = _.difference(imapIds, cozyIds.map(function(ids) {
      return ids[1];
    }));
    toRemove = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = cozyIds.length; _i < _len; _i++) {
        ids = cozyIds[_i];
        if (_ref = ids[1], __indexOf.call(imapIds, _ref) < 0) {
          _results.push(ids[0]);
        }
      }
      return _results;
    })();
    log.info('FETCHING', box.path);
    log.info('   in imap', imapIds.length);
    log.info('   in cozy', cozyIds.length);
    log.info('   to fetch', toFetch.length);
    log.info('   to del', toRemove.length);
    log.info('   limited', limitByBox);
    toFetch.reverse();
    if (limitByBox) {
      toFetch = toFetch.slice(0, +limitByBox + 1 || 9e9);
    }
    toDo = [];
    if (toFetch.length) {
      toDo.push(ImapProcess.fetchMails(account, box, toFetch));
    }
    if (toRemove.length) {
      toDo.push(ImapProcess.removeMails(account, box, toRemove));
    }
    reporter.onDone();
    return Promise.all(toDo);
  });
};

ImapProcess.fetchMails = function(account, box, uids) {
  var reporter;
  reporter = ImapReporter.addUserTask({
    code: 'apply-diff-fetch',
    account: account.label,
    box: box.path,
    total: uids.length
  });
  return Promise.map(uids, function(id) {
    return ImapProcess.fetchOneMail(account, box, id).tap(function() {
      return reporter.addProgress(1);
    })["catch"](function(err) {
      return reporter.onError(err);
    });
  }).tap(function() {
    return reporter.onDone();
  });
};

ImapProcess.removeMails = function(account, box, cozyIDs) {
  var reporter;
  reporter = ImapReporter.addUserTask({
    code: 'apply-diff-remove',
    account: account.label,
    box: box.path,
    total: cozyIDs.length
  });
  return Promise.serie(cozyIDs, function(id) {
    return Message.findPromised(id).then(function(message) {
      return message.removeFromMailbox(box);
    }).tap(function() {
      return reporter.addProgress(1);
    })["catch"](function(err) {
      return reporter.onError(err);
    });
  }).tap(function() {
    return reporter.onDone();
  });
};

ImapProcess.createMail = function(account, box, mail) {
  var message, scheduler;
  message = new Compiler(mail).compile().build();
  scheduler = ImapScheduler.instanceFor(account);
  return scheduler.doASAP(function(imap) {
    return imap.append(message, {
      mailbox: box.path
    });
  });
};

ImapProcess.fetchOneMail = function(account, box, uid) {
  var scheduler;
  scheduler = ImapScheduler.instanceFor(account);
  return scheduler.doLater(function(imap) {
    var mail;
    mail = null;
    return imap.openBox(box.path).then(function() {
      return imap.fetchOneMail(uid);
    }).then(function(fetched) {
      mail = fetched;
      return Message.byMessageId(account.id, mail.headers['message-id']);
    }).then(function(existing) {
      if (existing) {
        return existing.addToMailbox(box, uid).tap(function() {
          return log.info("MAIL " + box.path + "#" + uid + " ADDED TO BOX");
        });
      } else {
        return Message.createFromImapMessage(mail, box, uid).tap(function() {
          return log.info("MAIL " + box.path + "#" + uid + " CREATED");
        });
      }
    });
  });
};

ImapProcess.applyMessageChanges = function(msg, flagsOps, boxOps) {
  var boxIndex;
  log.info("MESSAGE CHANGE");
  log.info("BASE");
  log.info("CHANGES", flagsOps, boxOps);
  boxIndex = {};
  return Promise.all([
    Account.findPromised(msg.accountID).then(function(account) {
      return ImapScheduler.instanceFor(account);
    }), Mailbox.getBoxes(msg.accountID).then(function(boxes) {
      var box, uid, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = boxes.length; _i < _len; _i++) {
        box = boxes[_i];
        uid = msg.mailboxIDs[box.id];
        _results.push(boxIndex[box.id] = {
          path: box.path,
          uid: uid
        });
      }
      return _results;
    })
  ]).spread(function(scheduler) {
    return scheduler.doASAP(function(imap) {
      var boxid, uid, _i, _len, _ref;
      _ref = boxOps.addTo;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        boxid = _ref[_i];
        if (!boxIndex[boxid]) {
          throw new Error("the box ID=" + box + " doesn't exists");
        }
      }
      boxid = Object.keys(msg.mailboxIDs)[0];
      uid = msg.mailboxIDs[boxid];
      return imap.openBox(boxIndex[boxid].path).then(function() {
        if (flagsOps.add.length) {
          return imap.addFlags(uid, flagsOps.add);
        }
      }).then(function() {
        if (flagsOps.remove.length) {
          return imap.delFlags(uid, flagsOps.remove);
        }
      }).then(function() {
        log.info("CHANGED FLAGS " + boxIndex[boxid].path + ":" + uid, "ADD", flagsOps.add, "REMOVE", flagsOps.remove);
        msg.flags = _.union(msg.flags, flagsOps.add);
        msg.flags = _.difference(msg.flags, flagsOps.remove);
        return log.info("   RESULT = ", msg.flags);
      }).then(function() {
        return Promise.serie(boxOps.addTo, function(destId) {
          return imap.copy(uid, boxIndex[destId].path).then(function(uidInDestination) {
            log.info("COPIED " + boxIndex[boxid].path + ":" + uid, " TO " + boxIndex[destId].path + ":" + uidInDestination);
            return msg.mailboxIDs[destId] = uidInDestination;
          });
        }).then(function() {
          return Promise.serie(boxOps.removeFrom, function(boxid) {
            var path, _ref1;
            _ref1 = boxIndex[boxid], path = _ref1.path, uid = _ref1.uid;
            return imap.openBox(path).then(function() {
              return imap.addFlags(uid, '\\Deleted');
            }).then(function() {
              return imap.expunge(uid);
            }).then(function() {
              return delete msg.mailboxIDs[boxid];
            }).tap(function() {
              return log.info("DELETED " + path + ":" + uid);
            });
          });
        });
      });
    });
  });
};
