// Generated by CoffeeScript 1.7.1
var Account, ImapPromised, ImapReporter, ImapScheduler, Message, Promise, TestScheduler, UIDValidityChanged, log, mailutils, _,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

log = require('../utils/logging')({
  prefix: 'imap:scheduler'
});

Promise = (function() {
  function Promise() {}

  return Promise;

})();

ImapPromised = require('./imap_promisified');

ImapReporter = require('./imap_reporter');

Promise = require('bluebird');

_ = require('lodash');

UIDValidityChanged = require('../utils/errors').UIDValidityChanged;

Message = require('../models/message');

mailutils = require('../utils/jwz_tools');

Account = require('../models/account');

module.exports = ImapScheduler = (function() {
  ImapScheduler.instances = {};

  ImapScheduler.instanceFor = function(accountID, account) {
    var pAccount, scheduler;
    if (scheduler = this.instances[accountID]) {
      return Promise.resolve(scheduler);
    }
    pAccount = account ? Promise.resolve(account) : Account.findPromised(accountID);
    return pAccount.then((function(_this) {
      return function(account) {
        scheduler = (account == null) || account.isTest() ? new TestScheduler() : new ImapScheduler(account.makeImapConfig());
        _this.instances[accountID] = scheduler;
        return scheduler;
      };
    })(this));
  };

  ImapScheduler.prototype.tasks = [];

  ImapScheduler.prototype.pendingTask = null;

  function ImapScheduler(config) {
    this._dequeue = __bind(this._dequeue, this);
    this._rejectPending = __bind(this._rejectPending, this);
    this._resolvePending = __bind(this._resolvePending, this);
    this.closeConnection = __bind(this.closeConnection, this);
    this.config = config;
    this.accoutnID = config._id;
  }

  ImapScheduler.prototype.createNewConnection = function() {
    log.info("OPEN IMAP CONNECTION", this.config.label);
    this.imap = new ImapPromised(this.config);
    this.imap.onTerminated = (function(_this) {
      return function(err) {
        log.error('IMAP TERMINATED', err);
        if (_this.pendingTask) {
          _this._rejectPending(new Error('connection closed'));
        }
        if (_this.closingTimer) {
          clearTimeout(_this.closingTimer);
          _this.closingTimer = null;
        }
        return _this.closeConnection(true);
      };
    })(this);
    return this.imap.waitConnected["catch"]((function(_this) {
      return function(err) {
        var task;
        log.error("FAILED TO CONNECT", err, _this.tasks.length);
        while (task = _this.tasks.shift()) {
          task.reject(err);
        }
        throw err;
      };
    })(this)).tap((function(_this) {
      return function() {
        return _this._dequeue();
      };
    })(this));
  };

  ImapScheduler.prototype.closeConnection = function(hard) {
    return this.imap.end(hard).then((function(_this) {
      return function() {
        log.info("CLOSED CONNECTION ", (hard ? "HARD" : ""));
        _this.imap = null;
        return _this._dequeue();
      };
    })(this));
  };

  ImapScheduler.prototype.doASAP = function(gen) {
    return this.queue(true, gen);
  };

  ImapScheduler.prototype.doLater = function(gen) {
    return this.queue(false, gen);
  };

  ImapScheduler.prototype.queue = function(urgent, gen) {
    if (urgent == null) {
      urgent = false;
    }
    return new Promise((function(_this) {
      return function(resolve, reject) {
        var fn;
        fn = urgent ? 'unshift' : 'push';
        _this.tasks[fn]({
          attempts: 0,
          generator: gen,
          resolve: resolve,
          reject: reject
        });
        return _this._dequeue();
      };
    })(this));
  };

  ImapScheduler.prototype.doASAPWithBox = function(box, gen) {
    return this.queueWithBox(true, box, gen);
  };

  ImapScheduler.prototype.doLaterWithBox = function(box, gen) {
    return this.queueWithBox(false, box, gen);
  };

  ImapScheduler.prototype.queueWithBox = function(urgent, box, gen) {
    return this.queue(urgent, function(imap) {
      var uidvalidity;
      uidvalidity = null;
      return imap.openBox(box.path).then(function(imapbox) {
        if (!imapbox.persistentUIDs) {
          throw new Error('UNPERSISTENT UID NOT SUPPORTED');
        }
        if (box.uidvalidity && box.uidvalidity !== imapbox.uidvalidity) {
          throw new UIDValidityChanged(imapbox.uidvalidity);
        }
        return gen(imap, imapbox).tap(function() {
          if (!box.uidvalidity) {
            log.info("FIRST UIDVALIDITY", imapbox.uidvalidity);
            return box.updateAttributesPromised({
              uidvalidity: imapbox.uidvalidity
            });
          }
        });
      });
    })["catch"](UIDValidityChanged, (function(_this) {
      return function(err) {
        log.info("UIDVALIDITY", box.uidvalidity, err.newUidvalidity);
        log.warn("UID VALIDITY HAS CHANGED, RECOVERING");
        return _this.doASAP(function(imap) {
          return box.recoverChangedUIDValidity(imap);
        }).then(function() {
          return box.updateAttributesPromised({
            uidvalidity: err.newUidvalidity
          });
        }).then(function() {
          log.warn("RECOVERED");
          return _this.queueWithBox(urgent, box, gen);
        });
      };
    })(this));
  };

  ImapScheduler.prototype._resolvePending = function(result) {
    this.pendingTask.resolve(result);
    this.pendingTask = null;
    return setTimeout(this._dequeue, 1);
  };

  ImapScheduler.prototype._rejectPending = function(err) {
    this.pendingTask.reject(err);
    this.pendingTask = null;
    return setTimeout(this._dequeue, 1);
  };

  ImapScheduler.prototype._dequeue = function() {
    var moreTasks, _ref, _ref1, _ref2;
    if (this.pendingTask) {
      return false;
    }
    if ((_ref = this.imap) != null ? _ref.waitConnected.isPending() : void 0) {
      return false;
    }
    if ((_ref1 = this.imap) != null ? (_ref2 = _ref1.waitEnding) != null ? _ref2.isPending() : void 0 : void 0) {
      return false;
    }
    moreTasks = this.tasks.length !== 0;
    if (!moreTasks && !this.imap) {
      return false;
    }
    if (this.imap && !moreTasks) {
      if (this.closingTimer == null) {
        this.closingTimer = setTimeout(this.closeConnection, 3000);
      }
      return false;
    }
    if (this.closingTimer) {
      clearTimeout(this.closingTimer);
      this.closingTimer = null;
    }
    if (moreTasks && !this.imap) {
      this.createNewConnection();
      return false;
    }
    this.pendingTask = this.tasks.shift();
    return Promise.resolve(this.pendingTask.generator(this.imap)).timeout(120000)["catch"](Promise.TimeoutError, (function(_this) {
      return function(err) {
        log.error("TASK GOT STUCKED");
        _this.closeConnection(true);
        throw err;
      };
    })(this)).then(this._resolvePending, this._rejectPending);
  };

  return ImapScheduler;

})();

TestScheduler = (function() {
  function TestScheduler() {}

  TestScheduler.prototype.doASAP = function(gen) {
    return Promise.resolve(null);
  };

  TestScheduler.prototype.doASAPWithBox = function(gen) {
    return Promise.resolve(null);
  };

  TestScheduler.prototype.doLater = function(gen) {
    return Promise.resolve(null);
  };

  TestScheduler.prototype.doLaterWithBox = function(gen) {
    return Promise.resolve(null);
  };

  return TestScheduler;

})();
