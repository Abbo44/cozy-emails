// Generated by CoffeeScript 1.7.1
var Account, AccountConfigError, BadRequest, MSGBYPAGE, Mailbox, Message, NotFound, Promise, formatMessage, htmlToText, htmlToTextOptions, querystring, sanitizer, _, _ref;

Message = require('../models/message');

Account = require('../models/account');

Mailbox = require('../models/mailbox');

_ref = require('../utils/errors'), NotFound = _ref.NotFound, BadRequest = _ref.BadRequest, AccountConfigError = _ref.AccountConfigError;

MSGBYPAGE = require('../utils/constants').MSGBYPAGE;

Promise = require('bluebird');

htmlToText = require('html-to-text');

sanitizer = require('sanitizer');

_ = require('lodash');

querystring = require('querystring');

htmlToTextOptions = {
  tables: true,
  wordwrap: 80
};

formatMessage = function(message) {
  if (message.html != null) {
    message.html = sanitizer.sanitize(message.html, function(value) {
      return value.toString();
    });
  }
  if (message.text == null) {
    message.text = htmlToText.fromString(message.html, htmlToTextOptions);
  }
  return message;
};

module.exports.listByMailbox = function(req, res, next) {
  var FLAGS_CONVERT, after, before, descending, flag, flagcode, mailboxID, pageAfter, sort, sortField;
  sort = req.query.sort ? req.query.sort : '-date';
  descending = sort.substring(0, 1);
  if (descending === '+') {
    descending = false;
  } else if (descending === '-') {
    descending = true;
  } else {
    return next(new BadRequest("Unsuported sort order " + descending));
  }
  pageAfter = req.query.pageAfter;
  sortField = sort.substring(1);
  before = req.query.before;
  after = req.query.after;
  if (sortField === 'date') {
    if (before == null) {
      before = new Date(0).toISOString();
    }
    if (after == null) {
      after = new Date().toISOString();
    }
    if (new Date(before).toISOString() !== before || new Date(after).toISOString() !== after) {
      return next(new BadRequest("before & after should be a valid JS " + "date.toISOString()"));
    }
  } else if (sortField === 'subject') {
    before = before ? decodeURIComponent(before) : '';
    after = after ? decodeURIComponent(after) : {};
    pageAfter = pageAfter ? decodeURIComponent(pageAfter) : void 0;
  } else {
    return next(new BadRequest("Unsuported sort field " + sortField));
  }
  FLAGS_CONVERT = {
    'seen': '\\Seen',
    'unseen': '!\\Seen',
    'flagged': '\\Flagged',
    'unflagged': '!\\Flagged',
    'answered': '\\Answered',
    'unanswered': '!\\Answered'
  };
  flagcode = req.query.flag;
  if (flagcode) {
    flag = FLAGS_CONVERT[flagcode];
    if (!flag) {
      return next(new BadRequest("Unsuported flag filter"));
    }
  } else {
    flag = null;
  }
  mailboxID = req.params.mailboxID;
  return Message.getResultsAndCount(mailboxID, {
    sortField: sortField,
    descending: descending,
    before: before,
    after: after,
    resultsAfter: pageAfter,
    flag: flag
  }).then(function(result) {
    var last, links, messages, _ref1;
    messages = result.messages;
    if (messages.length === MSGBYPAGE) {
      last = messages[messages.length - 1];
      pageAfter = sortField === 'date' ? last.date.toISOString() : last.normSubject;
      links = {
        next: ("/mailbox/" + mailboxID + "?") + querystring.stringify({
          flag: flagcode,
          sort: sort,
          before: before,
          after: after,
          pageAfter: pageAfter
        })
      };
    } else {
      links = {};
    }
    return res.send(200, {
      mailboxID: mailboxID,
      messages: ((_ref1 = result.messages) != null ? _ref1.map(formatMessage) : void 0) || [],
      count: result.count,
      links: links
    });
  })["catch"](next);
};

module.exports.fetch = function(req, res, next) {
  return Message.findPromised(req.params.messageID).throwIfNull(function() {
    return new NotFound("Message " + req.params.messageID);
  }).then(function(message) {
    return req.message = message;
  }).nodeify(next);
};

module.exports.details = function(req, res, next) {
  return res.send(200, formatMessage(req.message));
};

module.exports.attachment = function(req, res, next) {
  var stream;
  stream = req.message.getBinary(req.params.attachment, function(err) {
    if (err) {
      return next(err);
    }
  });
  stream.on('error', next);
  return stream.pipe(res);
};

module.exports.patch = function(req, res, next) {
  return req.message.applyPatchOperations(req.body).then(function() {
    return res.send(200, formatMessage(req.message));
  })["catch"](next);
};

module.exports.send = function(req, res, next) {
  var message;
  message = req.body;
  message.attachments.map(function(attachment) {
    return {
      filename: attachment.filename,
      contents: new Buffer(attachment.content.split(",")[1], 'base64')
    };
  });
  return Account.findPromised(message.accountID).throwIfNull(function() {
    return new NotFound("Account " + message.accountID);
  }).then(function(account) {
    return Mailbox.findPromised(account.draftMailbox).then(function(draftBox) {
      return [account, draftBox];
    });
  }).spread(function(account, draftBox) {
    var out, removeOld;
    removeOld = function() {
      var uid, _ref1;
      uid = (_ref1 = message.mailboxIDs) != null ? _ref1[draftBox != null ? draftBox.id : void 0] : void 0;
      if (uid) {
        return draftBox != null ? draftBox.imap_removeMail(uid) : void 0;
      } else {
        return Promise.resolve(null);
      }
    };
    message.flags = ['\\Seen'];
    if (message.isDraft) {
      out = removeOld().then(function() {
        if (!draftBox) {
          throw new AccountConfigError('draftMailbox');
        }
        message.flags.push('\\Draft');
        return account.imap_createMail(draftBox, message);
      });
    } else {
      out = account.sendMessagePromised(message).then(function(info) {
        return message.headers['message-id'] = info.messageId;
      }).then(function() {
        return removeOld();
      }).then(function() {
        return Mailbox.findPromised(account.sentMailbox);
      }).then(function(sentBox) {
        return account.imap_createMail(sentBox, message);
      });
    }
    return out;
  }).spread(function(dest, uidInDest) {
    message.mailboxIDs = {};
    message.mailboxIDs[dest.id] = uidInDest;
    message.date = new Date().toISOString();
    if (message.id) {
      return Message.findPromised(message.id).then(function(jdbMessage) {
        return jdbMessage.updateAttributesPromised(message);
      });
    } else {
      return Message.createPromised(message);
    }
  }).then(function(msg) {
    return res.send(200, msg);
  })["catch"](next);
};

module.exports.search = function(req, res, next) {
  var numPageCheat;
  if (req.params.query == null) {
    return next(new BadRequest('`query` body field is mandatory'));
  }
  numPageCheat = parseInt(req.params.numPage) * parseInt(req.params.numByPage) + 1;
  return Message.searchPromised({
    query: req.params.query,
    numPage: req.params.numPage,
    numByPage: numPageCheat
  }).then(function(messages) {
    return res.send(200, messages.map(formatMessage));
  })["catch"](next);
};

module.exports.index = function(req, res, next) {
  return Message.requestPromised('all', {}).map(function(message) {
    return messages.indexPromised(['subject', 'text']);
  }).then(function() {
    return res.send(200, 'Indexation OK');
  })["catch"](next);
};

module.exports.del = function(req, res, next) {
  return Account.findPromised(req.message.accountID).throwIfNull(function() {
    return new NotFound("Account " + req.message.accountID);
  }).then(function(account) {
    var patch, trashID;
    trashID = account.trashMailbox;
    if (!trashID) {
      throw new AccountConfigError('trashMailbox');
    }
    patch = Object.keys(req.message.mailboxIDs).filter(function(boxid) {
      return boxid !== trashID;
    }).map(function(boxid) {
      return {
        op: 'remove',
        path: "/mailboxIDs/" + boxid
      };
    });
    patch.push({
      op: 'add',
      path: "/mailboxIDs/" + trashID
    });
    return req.message.applyPatchOperations(patch);
  }).then(function() {
    return res.send(200, req.message);
  })["catch"](next);
};

module.exports.conversationGet = function(req, res, next) {
  return Message.byConversationId(req.params.conversationID).then(function(messages) {
    return res.send(200, messages.map(formatMessage));
  })["catch"](next);
};

module.exports.conversationDelete = function(req, res, next) {
  return res.send(200, []);
};

module.exports.conversationPatch = function(req, res, next) {
  return Message.byConversationId(req.params.conversationID).then(function(messages) {
    return Promise.serie(messages, function(msg) {
      return msg.applyPatchOperations(req.body);
    }).then(function() {
      return res.send(200, messages);
    });
  })["catch"](next);
};
