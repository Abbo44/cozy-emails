// Generated by CoffeeScript 1.7.1
var Account, AccountConfigError, HttpError, Mailbox, Message, NotFound, Promise, formatMessage, htmlToText, htmlToTextOptions, sanitizer, _, _ref;

Message = require('../models/message');

Account = require('../models/account');

Mailbox = require('../models/mailbox');

_ref = require('../utils/errors'), NotFound = _ref.NotFound, HttpError = _ref.HttpError, AccountConfigError = _ref.AccountConfigError;

Promise = require('bluebird');

htmlToText = require('html-to-text');

sanitizer = require('sanitizer');

_ = require('lodash');

htmlToTextOptions = {
  tables: true,
  wordwrap: 80
};

formatMessage = function(message) {
  if (message.html != null) {
    message.html = sanitizer.sanitize(message.html, function(value) {
      return value.toString();
    });
  }
  if (message.text == null) {
    message.text = htmlToText.fromString(message.html, htmlToTextOptions);
  }
  return message;
};

module.exports.listByMailbox = function(req, res, next) {
  var after, before, descending, sortField, _base;
  if ((_base = req.query).sort == null) {
    _base.sort = '-date';
  }
  descending = req.query.sort.substring(0, 1);
  if (descending === '+') {
    descending = false;
  } else if (descending === '-') {
    descending = true;
  } else {
    return next(new HttpError(400, "Unsuported sort order " + descending));
  }
  sortField = req.query.sort.substring(1);
  if (sortField === 'date') {
    before = req.query.before || new Date(0).toISOString();
    after = req.query.after || new Date().toISOString();
    if (new Date(before).toISOString() !== before || new Date(after).toISOString() !== after) {
      return next(new HttpError(400, "before & after should be a valid JS date.toISOString()"));
    }
  } else if (sortField === 'subject') {
    before = decodeURIComponent(req.query.before) || '';
    after = decodeURIComponent(req.query.after) || {};
  } else {
    return next(new HttpError(400, "Unsuported sort field " + sortField));
  }
  return Message.getResultsAndCount(req.params.mailboxID, {
    sortField: sortField,
    descending: descending,
    before: before,
    after: after
  }).then(function(result) {
    var _ref1;
    return res.send(200, {
      mailboxID: req.params.mailboxID,
      messages: ((_ref1 = result.messages) != null ? _ref1.map(formatMessage) : void 0) || [],
      count: result.count
    });
  })["catch"](next);
};

module.exports.fetch = function(req, res, next) {
  return Message.findPromised(req.params.messageID).throwIfNull(function() {
    return new NotFound("Message " + req.params.messageID);
  }).then(function(message) {
    return req.message = message;
  }).nodeify(next);
};

module.exports.details = function(req, res, next) {
  return res.send(200, formatMessage(req.message));
};

module.exports.attachment = function(req, res, next) {
  var stream;
  stream = req.message.getBinary(req.params.attachment, function(err) {
    if (err) {
      return next(err);
    }
  });
  stream.on('error', next);
  return stream.pipe(res);
};

module.exports.patch = function(req, res, next) {
  return req.message.applyPatchOperations(req.body).then(function() {
    return res.send(200, formatMessage(req.message));
  })["catch"](next);
};

module.exports.send = function(req, res, next) {
  var message;
  message = req.body;
  message.attachments.map(function(attachment) {
    return {
      filename: attachment.filename,
      contents: new Buffer(attachment.content.split(",")[1], 'base64')
    };
  });
  return Account.findPromised(message.accountID).throwIfNull(function() {
    return new NotFound("Account " + message.accountID);
  }).then(function(account) {
    return Mailbox.findPromised(account.draftMailbox).then(function(draftBox) {
      return [account, draftBox];
    });
  }).spread(function(account, draftBox) {
    var out, removeOld;
    removeOld = function() {
      var uid, _ref1;
      uid = (_ref1 = message.mailboxIDs) != null ? _ref1[draftBox != null ? draftBox.id : void 0] : void 0;
      if (uid) {
        return draftBox != null ? draftBox.imap_removeMail(uid) : void 0;
      } else {
        return Promise.resolve(null);
      }
    };
    message.flags = ['\\Seen'];
    if (message.isDraft) {
      out = removeOld().then(function() {
        if (!draftBox) {
          throw new AccountConfigError('draftMailbox');
        }
        message.flags.push('\\Draft');
        return account.imap_createMail(draftBox, message);
      });
    } else {
      out = account.sendMessagePromised(message).then(function(info) {
        return message.headers['message-id'] = info.messageId;
      }).then(function() {
        return removeOld();
      }).then(function() {
        return Mailbox.findPromised(account.sentMailbox);
      }).then(function(sentBox) {
        return account.imap_createMail(sentBox, message);
      });
    }
    return out;
  }).spread(function(dest, uidInDest) {
    message.mailboxIDs = {};
    message.mailboxIDs[dest.id] = uidInDest;
    message.date = new Date().toISOString();
    if (message.id) {
      return Message.findPromised(message.id).then(function(jdbMessage) {
        return jdbMessage.updateAttributesPromised(message);
      });
    } else {
      return Message.createPromised(message);
    }
  }).then(function(msg) {
    return res.send(200, msg);
  })["catch"](next);
};

module.exports.search = function(req, res, next) {
  var numPageCheat;
  if (req.params.query == null) {
    return next(new HttpError(400, '`query` body field is mandatory'));
  }
  numPageCheat = parseInt(req.params.numPage) * parseInt(req.params.numByPage) + 1;
  return Message.searchPromised({
    query: req.params.query,
    numPage: req.params.numPage,
    numByPage: numPageCheat
  }).then(function(messages) {
    return res.send(200, messages.map(formatMessage));
  })["catch"](next);
};

module.exports.index = function(req, res, next) {
  return Message.requestPromised('all', {}).map(function(message) {
    return messages.indexPromised(['subject', 'text']);
  }).then(function() {
    return res.send(200, 'Indexation OK');
  })["catch"](next);
};

module.exports.del = function(req, res, next) {
  return Account.findPromised(req.message.accountID).throwIfNull(function() {
    return new NotFound("Account " + req.message.accountID);
  }).then(function(account) {
    var patch, trashID;
    trashID = account.trashMailbox;
    if (!trashID) {
      throw new AccountConfigError('trashMailbox');
    }
    patch = Object.keys(req.message.mailboxIDs).filter(function(boxid) {
      return boxid !== trashID;
    }).map(function(boxid) {
      return {
        op: 'remove',
        path: "/mailboxIDs/" + boxid
      };
    });
    patch.push({
      op: 'add',
      path: "/mailboxIDs/" + trashID
    });
    return req.message.applyPatchOperations(patch);
  }).then(function() {
    return res.send(200, req.message);
  })["catch"](next);
};

module.exports.conversationDelete = function(req, res, next) {
  return res.send(200, []);
};

module.exports.conversationPatch = function(req, res, next) {
  return Message.byConversationID(req.params.conversationID).then(function(messages) {
    return Promise.serie(messages, function(msg) {
      return msg.applyPatchOperations(req.body);
    }).then(function() {
      return res.send(200, messages);
    });
  })["catch"](next);
};
