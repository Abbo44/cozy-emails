// Generated by CoffeeScript 1.7.1
var Account, Client, HttpError, ImapProcess, Mailbox, Message, Promise, WrongConfigError, async, dataSystem, formatMessage, htmlToText, htmlToTextOptions, jsonpatch, nodemailer, password, sanitizer, user, _ref, _ref1;

async = require('async');

Message = require('../models/message');

Account = require('../models/account');

Mailbox = require('../models/mailbox');

_ref = require('../utils/errors'), HttpError = _ref.HttpError, WrongConfigError = _ref.WrongConfigError;

Client = require('request-json').JsonClient;

jsonpatch = require('fast-json-patch');

nodemailer = require('nodemailer');

Promise = require('bluebird');

htmlToText = require('html-to-text');

sanitizer = require('sanitizer');

ImapProcess = require('../processes/imap_processes');

htmlToTextOptions = {
  tables: true,
  wordwrap: 80
};

dataSystem = new Client('http://localhost:9101/');

if ((_ref1 = process.env.NODE_ENV) === 'production' || _ref1 === 'test') {
  user = process.env.NAME;
  password = process.env.TOKEN;
  dataSystem.setBasicAuth(user, password);
}

formatMessage = function(message) {
  if (message.html != null) {
    message.html = sanitizer.sanitize(message.html, function(value) {
      return value.toString();
    });
  }
  if (message.text == null) {
    message.text = htmlToText.fromString(message.html, htmlToTextOptions);
  }
  return message;
};

module.exports.listByMailboxId = function(req, res, next) {
  var options;
  options = {
    numPage: req.params.numPage - 1,
    numByPage: req.params.numByPage
  };
  return Promise.all([Message.getByMailboxAndDate(req.params.mailboxID, options), Message.countByMailbox(req.params.mailboxID), Message.countReadByMailbox(req.params.mailboxID)]).spread(function(messages, count, read) {
    return res.send(200, {
      mailboxID: req.params.mailboxID,
      messages: messages.map(formatMessage),
      count: count,
      unread: count - read
    });
  })["catch"](next);
};

module.exports.fetch = function(req, res, next) {
  return Message.findPromised(req.params.messageID).then(function(message) {
    if (message) {
      return req.message = message;
    } else {
      throw new HttpError(404, 'Not Found');
    }
  }).nodeify(next);
};

module.exports.details = function(req, res, next) {
  return res.send(200, formatMessage(req.message));
};

module.exports.attachment = function(req, res, next) {
  var stream;
  stream = req.message.getBinary(req.params.attachment, function(err) {
    if (err) {
      return next(err);
    }
  });
  stream.on('error', next);
  return stream.pipe(res);
};

module.exports.patch = function(req, res, next) {
  return req.message.applyPatchOperations(req.body).then(function() {
    return res.send(200, formatMessage(req.message));
  })["catch"](next);
};

module.exports.send = function(req, res, next) {
  var message;
  message = req.body;
  message.attachments.map(function(attachment) {
    return {
      filename: attachment.filename,
      contents: new Buffer(attachment.content.split(",")[1], 'base64')
    };
  });
  return Account.findPromised(message.accountID).then(function(account) {
    return Mailbox.findPromised(account.draftMailbox).then(function(draftBox) {
      return [account, draftBox];
    });
  }).spread(function(account, draftBox) {
    var out, removeOld;
    removeOld = function() {
      var uid, _ref2;
      uid = (_ref2 = message.mailboxIDs) != null ? _ref2[draftBox != null ? draftBox.id : void 0] : void 0;
      if (uid) {
        return ImapProcess.remove(account, draftBox, uid);
      } else {
        return Promise.resolve();
      }
    };
    message.flags = ['\\Seen'];
    if (message.isDraft) {
      return out = removeOld().then(function() {
        if (!draftBox) {
          throw new WrongConfigError('need a draftbox');
        }
        message.flags.push('\\Draft');
        return ImapProcess.createMail(account, draftBox, message);
      });
    } else {
      return out = account.sendMessagePromised(message).then(function(info) {
        return message.headers['message-id'] = info.messageId;
      }).then(function() {
        return removeOld();
      }).then(function() {
        return Mailbox.findPromised(account.sentMailbox);
      }).then(function(sentBox) {
        return ImapProcess.createMail(account, sentBox, message);
      });
    }
  }).spread(function(dest, uidInDest) {
    message.mailboxIDs = {};
    message.mailboxIDs[dest.id] = uidInDest;
    message.date = new Date().toISOString();
    if (message.id) {
      return Message.findPromised(message.id).then(function(jdbMessage) {
        return jdbMessage.updateAttributesPromised(message);
      });
    } else {
      return Message.createPromised(message);
    }
  }).then(function(msg) {
    return res.send(200, msg);
  })["catch"](next);
};

module.exports.search = function(req, res, next) {
  var numPageCheat;
  if (req.params.query == null) {
    return next(new HttpError(400, '`query` body field is mandatory'));
  } else {
    numPageCheat = parseInt(req.params.numPage) * parseInt(req.params.numByPage) + 1;
    return Message.searchPromised({
      query: req.params.query,
      numPage: req.params.numPage,
      numByPage: numPageCheat
    }).then(function(messages) {
      return res.send(200, messages.map(formatMessage));
    })["catch"](next);
  }
};

module.exports.index = function(req, res, next) {
  return Message.request('all', {}, function(err, messages) {
    if (err != null) {
      return next(err);
    } else {
      return async.each(messages, function(message, callback) {
        return message.index(['subject', 'text'], callback);
      }, function(err) {
        if (err != null) {
          return next(err);
        } else {
          return res.send(200, 'Indexation OK');
        }
      });
    }
  });
};

module.exports.del = function(req, res, next) {
  return Account.findPromised(req.message.accountID).then(function(account) {
    var patch, trashID;
    trashID = account.trashMailbox;
    if (!trashID) {
      throw new WrongConfigError('need define trash');
    }
    patch = Object.keys(req.message.mailboxIDs).filter(function(boxid) {
      return boxid !== trashID;
    }).map(function(boxid) {
      return {
        op: 'remove',
        path: "/mailboxIDs/" + boxid
      };
    });
    patch.push({
      op: 'add',
      path: "/mailboxIDs/" + trashID
    });
    return req.message.applyPatchOperations(patch);
  }).then(function() {
    return res.send(200, req.message);
  })["catch"](next);
};

module.exports.conversationDelete = function(req, res, next) {
  return res.send(200, []);
};

module.exports.conversationPatch = function(req, res, next) {
  return Message.byConversationID(req.params.conversationID).then(function(messages) {
    return Promise.serie(messages, function(msg) {
      return msg.applyPatchOperations(req.body);
    }).then(function() {
      return res.send(200, messages);
    });
  })["catch"](next);
};
